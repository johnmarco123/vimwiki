Question 1.)
    a.) iii
    b.) iii
    c.)
        i.) 2
        ii.) 4
        iii.) 2
        iv.) 3
        v.) 2
    d.) i
    e.) iv
    f.) 
        i.) 5
        ii.) 14
    g.) i
    h.) ii
    i.) iv
    j.) ii
    k.) i
    l.) ii
    
Question 2.)
    a.) [1, 2, 3, 4, 5]
    b.) Stack looks like this STACK [4, 8] with 8 being the top of the stack 
    c.) 8 -> 4 -> NULL (with 8 being the head)
    d.) MISSING1 = FALSE, MISSING2 = POP[s]
    e.) The two parts of the function we must analyze to conclude the time
    complexity are MAKESTACK and the for loop thats in the function. Lets say n
    is equal to the length of the vector The MAKESTACK function iterates over
    from element 1 to element FLOOR(n / 2) and pushes the given elements inside
    of the stack data structure and returns it Since it iterates over half the
    vector this is O(n / 2). We then have the for loop which iterates from
    CEIL(n / 2) to n. This is also O(n/2). If we add both O(n / 2) together we
    get O(n). Therefore, the worst case time complexity is O(n).
    f.)
        i.) return FALSE
        ii.) return RECPALINDROME(vector, left + 1, right - 1)
    g.) The reason ISPALNEW is also O(n) time complexity is because of the
    following:
    We recursively check the left and right pointers for the vector we are
    checking. we then move both of those pointers towards one another by 1 each
    recursive iteration. This leads to a time complexity of O(n / 2), however
    in big O notation we this would be O(n).
    
Question 3.)
    a.) 
        i.) arr starts as [4, 2, 12, 1, 7, 9, 9]
                          [2, 4, 12, 1, 7, 9, 9]
                          [2, 4, 1, 12, 7, 9, 9]
                          [2, 4, 1, 7, 12, 9, 9]
                          [2, 4, 1, 7, 9, 12, 9]
                          [2, 4, 1, 7, 9, 9, 12]
                          [2, 1, 4, 7, 9, 9, 12]
                          [1, 2, 4, 7, 9, 9, 12]
                      
        ii.) bubble sort iterates from element 1 to element n on the first
        iteration. the second iteration it iterates through element 1 to n - 1
        it continues this until n = 1. In other words, the time complexity is
        O(n^2)
    
    b.) 
    By hand, work through the Quicksort algorithm on this vector where the
    pivot is the mid-point (calculated as the floor of half the sum of the left
    index plus the right index). Explicitly show how the vector changes in the
    algorithm. You should show how the vector changes in the algorithm. You
    should sort the vector in ascending order so the lowest value is in the
    first element.
        i.) arr starts as [6, 2, 3, 5, 4]
                          [2, 3, 6, 5, 4]
                          [2, 3, 4, 5, 6]
                          
        ii.) [3, 2, 1, 0]. This is a worst case input as every pivot chosen (in
        the middle) requires all elements on the left and right to be shifted.
        
        iii.) a small part of the quick sort algorithm is shown below in 
        javascript
        
        function qs(arr, lo, hi) {
            if (lo >= hi) {
                return;
            }
            let pivot = partition(arr, lo, hi);
            qs(arr, lo, pivot - 1);
            qs(arr, pivot + 1, hi);
        }

        We select a pivot (and shift all elements to the appropriate side of
        that pivot, whether that be left or right.

        We then call quicksort for the left subarray (to the left of the pivot)
        and the right subarray (to the right of the pivot)
