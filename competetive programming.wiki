= Dynamic programming =
    A dynamic-programming approach runs in polynomial time when the
    number of distinct subproblems involved is polynomial in the input
    size and we can solve each such subproblem in polynomial time. 
    
    = Top down with memoization: =
        This involves going in a normal order, and saving the results of each
        subproblem in a table. If we encounter a subproblem that we have
        already solved, we just look it up in the table. This is called
        memoization.
        
    = Bottom up: =
        This involves solving the subproblems in a bottom up fashion, and
        saving the results in a table. This approach typicallly depends on
        the natural nothing of the size of the subproblem, such that
        solving any particular subproblem depends only on solving
        "smaller" subproblems.
        
= Find bridges in a graph = 
    Bridges are edges whose removal increases the number of connected
    components.
    
    We have a list of connections in the form 
    arr[i] = all the connections from the vertex i
    
   Example solution in javascript:
   
let graph = (the graph explained above)
let low = [];
let ids = [];
let visited = [];
let bridges = [];
let id = 0;
function dfs(at, parent, bridges) {
    visited[at] = true;
    ids[at] = id;
    low[at] = id;
    ++id;
    for (let to of graph[at]) {
        if (parent == to) continue;
        if (!visited[to]) {
            dfs(to, at, bridges);
            low[at] = Math.min(low[at], low[to]);
            if (ids[at] < lo[to]) {
                bridges.push([at, to]);
            }
        } else {
            low[at] = Math.min(low[at], ids[to]);
        }
    }
}
dfs(0, -1, bridges); // we are assuming that all nodes are connected
return bridges
   
